# Day5_2022.05.04

题目

![image-20220511192944891](C:\Users\Yiyang Weng\AppData\Roaming\Typora\typora-user-images\image-20220511192944891.png)

![image-20220511192956093](C:\Users\Yiyang Weng\AppData\Roaming\Typora\typora-user-images\image-20220511192956093.png)

分析：

方法一：模拟 + 队列
最直观的方法是模拟游戏过程。使用队列存储圈子中的小伙伴编号，初始时将1到n的所有编号依次加入队列，队首元素即为第1名小伙伴的编号。

每一轮游戏中，从当前小伙伴开始数k名小伙伴，数到的第k名小伙伴离开圈子。模拟游戏过程的做法是，将队首元素取出并将该元素在队尾处重新加入队列，重复该操作k - 1次，则在k - 1次操作之后，队首元素即为这一轮中数到的第k名小伙伴的编号，将队首元素取出，即为数到的第k名小伙伴离开圈子。上述操作之后，新的队首元素即为下一轮游戏的起始小伙伴的编号。

每一轮游戏之后，圈子中减少一名小伙伴，队列中减少一个元素。重复上述过程，直到队列中只剩下1个元素，该元素即为获胜的小伙伴的编号。

```c++
class Solution {
public:
    int findTheWinner(int n, int k) {
        queue<int> qu;
        for (int i = 1; i <= n; i++) {
            qu.emplace(i);
        }
        while (qu.size() > 1) {
            for (int i = 1; i < k; i++) {
                qu.emplace(qu.front());
                qu.pop();
            }
            qu.pop();
        }
        return qu.front();
    }
};
```

