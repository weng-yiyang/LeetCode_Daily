# Day3_2022.05.02

题目：

![image-20220502140557469](C:\Users\Yiyang Weng\AppData\Roaming\Typora\typora-user-images\image-20220502140557469.png)

![image-20220502140615998](C:\Users\Yiyang Weng\AppData\Roaming\Typora\typora-user-images\image-20220502140615998.png)

![image-20220502140632802](C:\Users\Yiyang Weng\AppData\Roaming\Typora\typora-user-images\image-20220502140632802.png)

分析：

这道题要求验证给定的表示代码片段的字符串 code 是否为合法的标签【说白了就是是否符合匹配规则】。匹配验证时需要重点关注的是起始标签、结束标签和 cdata 三种不同的标签，读题可以发现将标签大概分为如下几类：

出现 ""
出现 "</"，去找">"
出现 "<"，去找">"，并将标签内容存入栈中，以后匹配
同时注意标签内容均为大写字母，标签长度小于等于9
注：其实最后发现此题就是高配版的括号匹配分析思路，比如做括号 ( 对应 <![CDATA[ 右括号 ) 对应 ]]> 等等，依然采用栈【先进后出】解决嵌套问题。

具体实现步骤：
1. 确定使用的数据类型【思路分析】
分析到这其实只是完成工作的一半，还需要确定使用什么数据类型，看到这个标签匹配其实很像之前做的一个题目就是【字符串的括号匹配】，也和本题思路类似也会有括号的嵌套【对应本题标签嵌套】，因此匹配标签顺序符合栈的「后进先出」的规则，因此可以使用栈验证标签。
2. 栈匹配标签的过程分析

遍历字符串
遇到起始标签【有以上分类讨论的一种】则入栈，遇到结束标签则判断是否和栈顶的起始标签匹配，如果匹配则将起始标签出栈，如果不匹配则代码片段不是有效的标签。==》》【和括号匹配思路一模一样】。
遍历完以后如果发现有字符在最外层闭合标签以外，则一定不是合法的标签。返回false
判断的方法是：如果当下标大于 0 且小于字符串长度时，栈为空，则说明存在一个字符在最外层闭合标签以外。
3. 对不同类型的起始标签进行分类讨论：
因为标签不是一个字符所以会用到两个函数：substr(起始位置, 结束位置)，find("待查找字符串", 起始位置)一个用于判断起始标签一个找到起始标签后面第一个出现与之匹配的结束标签。

截取字符串的前9个字符如果等于 "<![CDATA[" ==》 code.substr(i, 9) == "<![CDATA[" 此时 i 是 cdata 的起始位置，然后在起始位置之后找第一个 "]]>" 是 cdata 的结束位置 i i = code.find("]]>", j);
如果find找不到 "]]>"，返回值为小于零 则 cdata 是无效的，返回 false。
如果find找到 "]]>"，返回值 i 为找到的第一个位置 i+=2 是将下标移动到结束位置之后。
截取前2 个字符等于 "</"==》code.substr(i, 2) == "</" ， i 则是结束标签的起始位置，同上一样找到起始位置之后的第一个">" 是结束标签的结束位置。
找不到 ">"， if (i < 0) return false;
找到 ">"，截取标签内容看与之前存入的标签前段相比，是否匹配
字符 "<"，判断思路和上面一样【具体看代码吧加一条和上面不一样的判断】
合法的标签名满足长度在范围 [1,9] 内且全部是大写字母。
此时栈为空。当栈为空时返回 true，否则返回 false。

代码：

```c++
class Solution {
public:
    bool isValid(string code) {
        stack<string> st;
        for(int i = 0; i < code.size(); i++) {
            /* 分类1: 出现 "" */
            if(i > 0 && st.empty()) return false;
            /* 分类2: 出现"<![CDATA[" */
            if(code.substr(i, 9) == "<![CDATA[") { 
                int j = i + 9;
                i = code.find("]]>", j);// 找到"]]>"
                if (i < 0) return false;
                i += 2;
            }  /* 分类3: 出现"</" */
            else if(code.substr(i, 2) == "</") {   
                int j = i + 2;
                i = code.find(">", j);  //找到">"
                if (i < 0) return false;
                /* 截取标签内容 */
                string tag = code.substr(j, i - j); 
                /* 与之前存入的标签前段相比，是否匹配 */
                if (st.empty() || st.top() != tag) return false;  
                st.pop();
            }  /* 分类4: 出现"<" */
            else if(code.substr(i, 1) == "<") {   
                int j = i + 1;
                i = code.find(">", j);               //找到">"
                /* 如果标签长度超过9就错误 */
                if (i < 0 || i == j || i - j > 9) return false; 
                /* 标签字母要求大写 */
                for (int k = j; k < i; k++) 
                    if (code[k] < 'A' || code[k] > 'Z') return false;  
                /* 将标签内容存入栈中 */
                string tag = code.substr(j, i - j);  
                st.push(tag);
            }
        }
        return st.empty();
    }
};
```

笔记：

substr():用于复制字符串，从指定位置开始，具有指定长度

s.substr(pos,len)，pos默认为0，len默认s.size()-pos

find():find("]]>",j)，返回值为位置下标，第一个参数是带寻找的字符串，第二个参数是开始寻找的位置。
